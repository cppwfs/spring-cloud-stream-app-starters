//tag::ref-doc[]
= TaskLauncher Cloud Foundry Sink

The TaskLauncher-CloudFoundry sink consumes a `TaskLaunchRequest` message, then
deploys and launches a task using the Cloud Foundry Spring Cloud Deployer.

Any message received by the sink, that does not contain a `TaskLaunchRequest`
will log an error.

== Using the TaskLauncher
The task launcher will use the `--uri` from the TaskLaunchRequest to obtain the
task artifact to deploy.  It also obtains commandLineArguments,
deploymentProperties and environmentProperties from the TaskLaunchRequest that
will be used to deploy and execute the task.

An example of this using Spring Cloud Data Flow would be to create a
stream where a
link:https://github.com/spring-cloud/spring-cloud-stream-app-starters/tree/master/http[http]
source would send its messages to the
link:https://github.com/spring-cloud/spring-cloud-stream-app-starters/tree/master/processor/spring-cloud-starter-stream-processor-tasklaunchrequest-transform[taskLaunchRequestTransform]
processor. These messages are then translated to a TaskLaunchRequest and
sent to the cftask sink (which is a Cloud Foundry TaskLauncher).  For example:

*Create A Stream*

`stream create w7 --definition "http --port=9000 | taskLaunchRequestTransform
--uri=<uriToJar> | cftask"`

*Deploy The Stream*

`stream deploy w7 --properties "app.cftask.deployer.url=https://api.local.pcfdev.io, app.cftask.deployer.org=user-dataflow, app.cftask.deployer.space=development, app.cftask.deployer.domain=local.pcfdev.io, app.cftask.deployer.username=admin, app.cftask.deployer.password=admin, app.cftask.deployer.skipSslValidation=true, app.cftask.deployer.services=mysql, app.cftask.deployer.taskTimeout=300"`

This example deploys to pcfdev using a mysql database service with the
service name of `mysql`.  Also we can see that there is a taskTimeout of 300
seconds for staging the task.

//tag::configuration-properties[]
//end::configuration-properties[]

//end::ref-doc[]

== Build

```
$ mvn clean package
```
